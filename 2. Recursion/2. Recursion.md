# Справка по рекурсии

## Что такое рекурсия?

**Рекурсия** — это техника в программировании, при которой функция вызывает саму себя для решения задачи. Рекурсивные функции позволяют разбить задачу на более простые подзадачи, которые можно решать аналогично исходной задаче.

Рекурсия особенно полезна в задачах, которые могут быть естественным образом разделены на одинаковые подзадачи, например, при обходе деревьев, вычислении факториала, или поиске в глубину.

## Основные компоненты рекурсии

Каждая рекурсивная функция должна иметь следующие два компонента:

1. **Базовый случай (base case)**: это условие, при котором рекурсия прекращается. Базовый случай обеспечивает, что функция не будет вызывать саму себя бесконечно.
  
2. **Рекурсивный случай (recursive case)**: часть функции, в которой выполняется рекурсивный вызов, обычно с измененными параметрами, чтобы приблизить функцию к базовому случаю.

### Общий вид рекурсивной функции

```plaintext
function recursiveFunction(parameters):
    if (base case condition is met):
        return some base value
    else:
        return some operation that involves recursiveFunction(modified parameters)
```

## Пример общего алгоритма на псевдокоде

### Пример 1: Рекурсивный подсчет суммы от 1 до N

Задача: Написать функцию, которая рекурсивно вычисляет сумму всех чисел от 1 до N.

**Псевдокод:**

```plaintext
function sum(N):
    if N == 1:
        return 1
    else:
        return N + sum(N - 1)
```

**Объяснение:**

- **Базовый случай**: Если `N` равно 1, возвращаем 1.
- **Рекурсивный случай**: Возвращаем сумму `N` и вызова функции `sum(N - 1)`.

### Пример 2: Рекурсивное вычисление факториала

Задача: Вычислить факториал числа `N`.

**Псевдокод:**

```plaintext
function factorial(N):
    if N == 0 or N == 1:
        return 1
    else:
        return N * factorial(N - 1)
```

**Объяснение:**

- **Базовый случай**: Если `N` равно 0 или 1, возвращаем 1 (так как 0! = 1! = 1).
- **Рекурсивный случай**: Возвращаем произведение `N` и вызова функции `factorial(N - 1)`.

## Важные аспекты рекурсии

### 1. **Правильный базовый случай**

Базовый случай крайне важен для завершения рекурсии. Если базовый случай не реализован, функция будет вызывать саму себя бесконечно, что приведет к переполнению стека вызовов.

### 2. **Глубина рекурсии и переполнение стека**

Каждый вызов рекурсивной функции занимает место в стеке вызовов. Если количество вызовов слишком велико, может произойти переполнение стека (stack overflow). Это ограничивает количество рекурсивных вызовов, которое можно выполнить, и требует учитывать глубину рекурсии при проектировании алгоритма.

### 3. **Рекурсивные и нерекурсивные решения**

Многие задачи, которые можно решить рекурсивно, могут быть решены и итеративно (с использованием циклов). Итеративные решения часто более эффективны по времени выполнения и использованию памяти, но рекурсивные решения могут быть проще и понятнее.

### 4. **Косвенная рекурсия**

Иногда функция A вызывает функцию B, а функция B, в свою очередь, вызывает функцию A. Это называется косвенной рекурсией. Косвенная рекурсия может быть сложной в понимании и требует особого внимания.

### Пример косвенной рекурсии:

```plaintext
function A(x):
    if x > 0:
        return B(x - 1)
    else:
        return 0

function B(y):
    if y > 0:
        return A(y - 2)
    else:
        return 1
```

### 5. **Тейл-рекурсия (хвостовая рекурсия)**

Тейл-рекурсия — это специальный случай рекурсии, когда рекурсивный вызов функции является последним действием перед возвратом значения. В языках программирования, поддерживающих оптимизацию хвостовой рекурсии, такие функции могут быть преобразованы в итеративные вызовы, что позволяет экономить память.

**Пример хвостовой рекурсии:**

```plaintext
function tailRecursiveSum(N, accumulator):
    if N == 0:
        return accumulator
    else:
        return tailRecursiveSum(N - 1, accumulator + N)
```

### Преимущества и недостатки рекурсии

**Преимущества:**

- Простота и лаконичность кода для задач, которые естественно описываются рекурсией (например, обход деревьев, выполнение комбинаторных задач).
- Возможность решения сложных задач через декомпозицию на простые подзадачи.

**Недостатки:**

- Высокий расход памяти из-за необходимости хранения каждого вызова функции в стеке.
- Потенциальная угроза переполнения стека при глубокой рекурсии.
- Часто рекурсивные решения менее эффективны по времени выполнения, чем итеративные аналоги.